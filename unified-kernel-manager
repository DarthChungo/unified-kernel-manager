#!/bin/bash

#
# unified-kernel-manager
#
# Easily and automatically manage unified kernel images through
# this script and pacman hooks. Can generate and remove kernel
# images, as well as sign them for secure boot. Available options
# are:
#
#
# unified-kernel-manager generate
#
# Automatically generates unified kernel images for installed
# kernels. Includes both intel and amd microdes in the initrds.
# Generates both a fallback and normal version if a fallback
# initramfs is present for that kernel. Uses either /etc/kernel/cmdline
# or ${boot_dir}/cmdline-${kernel_name} for the kernel's cmdline.
#
#
# unified-kernel-manager remove <orphaned|all|<name>>
#
# Removes orphaned unified kernel images from a system's esp.
# Can be used with a pacman hook to remove leftover images
# when you uninstall a kernel to avoid orphaned efi images.
#
#
# unified-kernel-manager generate-keys
#
# Create secure boot keys in ${key_dir}. Automatically done
# when trying to sign kernels and they are missing.
#
#
# unified-kernel-manager sign
#
# Recursevly signs all efi executables inside ${esp_dir} using
# the keys located in ${key_dir}.
#
#
# unified-kernel-manager deploy
#
# Deploys secure boot keys. Requires firmware to be in setup
# mode.
#

# Config options

boot_dir=/boot
esp_dir=/efi
esp_name=Linux
efi_stub=/usr/lib/systemd/boot/efi/linuxx64.efi.stub
key_dir=/etc/unified-kernel-manager/keys

function error() {
  echo $@
  exit 1
}

function ret_error() {
  echo $@
  return 1
}

function require_set() {
  if [[ -z $1 ]]; then
    error "Unset config variable, refusing to continue"
  fi
}

require_set $boot_dir
require_set $esp_dir
require_set $esp_name
require_set $efi_stub
require_set $key_dir

if [ "$(id -u)" -ne 0 ]; then
  error "Please run as root"
fi

mkdir -p ${esp_dir}/EFI/${esp_name}
mkdir -p ${esp_dir}/EFI/BOOT
mkdir -p ${key_dir}

function print_usage() {
  echo "  unified-kernel-manager generate"
  echo "  unified-kernel-manager remove <orphaned|all|<name>>"
  echo "  unified-kernel-manager generate-keys"
  echo "  unified-kernel-manager sign"
  echo "  unified-kernel-manager deploy"
}

function check_keys() {
  if
    [[ ! -f ${key_dir}/PK.key   ]] ||
    [[ ! -f ${key_dir}/KEK.key  ]] ||
    [[ ! -f ${key_dir}/DB.key   ]] ||
    [[ ! -f ${key_dir}/PK.cer   ]] ||
    [[ ! -f ${key_dir}/KEK.cer  ]] ||
    [[ ! -f ${key_dir}/DB.cer   ]] ||
    [[ ! -f ${key_dir}/PK.crt   ]] ||
    [[ ! -f ${key_dir}/KEK.crt  ]] ||
    [[ ! -f ${key_dir}/DB.crt   ]] ||
    [[ ! -f ${key_dir}/PK.esl   ]] ||
    [[ ! -f ${key_dir}/KEK.esl  ]] ||
    [[ ! -f ${key_dir}/DB.esl   ]] ||
    [[ ! -f ${key_dir}/PK.auth  ]] ||
    [[ ! -f ${key_dir}/KEK.auth ]] ||
    [[ ! -f ${key_dir}/DB.auth  ]] ||
    [[ ! -f ${key_dir}/GUID.txt ]]; then
    return 0
  else
    return 1
  fi
}

function generate_keys() {
  echo "Generating secure boot keys"
  rm -f ${key_dir}/*

  2>/dev/null 1>&2 openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Secure Boot PK/" -keyout ${key_dir}/PK.key -out ${key_dir}/PK.crt -days 3650 -nodes -sha256
  2>/dev/null 1>&2 openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Secure Boot KEK/" -keyout ${key_dir}/KEK.key -out ${key_dir}/KEK.crt -days 3650 -nodes -sha256
  2>/dev/null 1>&2 openssl req -new -x509 -newkey rsa:2048 -subj "/CN=Secure Boot DB/" -keyout ${key_dir}/DB.key -out ${key_dir}/DB.crt -days 3650 -nodes -sha256
  2>/dev/null 1>&2 openssl x509 -in ${key_dir}/PK.crt -out ${key_dir}/PK.cer -outform DER
  2>/dev/null 1>&2 openssl x509 -in ${key_dir}/KEK.crt -out ${key_dir}/KEK.cer -outform DER
  2>/dev/null 1>&2 openssl x509 -in ${key_dir}/DB.crt -out ${key_dir}/DB.cer -outform DER

  GUID=$(uuidgen -r)
  echo $GUID > ${key_dir}/GUID.txt

  2>/dev/null 1>&2 cert-to-efi-sig-list -g $GUID ${key_dir}/PK.crt ${key_dir}/PK.esl
  2>/dev/null 1>&2 cert-to-efi-sig-list -g $GUID ${key_dir}/KEK.crt ${key_dir}/KEK.esl
  2>/dev/null 1>&2 cert-to-efi-sig-list -g $GUID ${key_dir}/DB.crt ${key_dir}/DB.esl

  2>/dev/null 1>&2 sign-efi-sig-list -t "$(date --date='1 second' +'%Y-%m-%d %H:%M:%S')" -k ${key_dir}/PK.key -c ${key_dir}/PK.crt PK ${key_dir}/PK.esl ${key_dir}/PK.auth
  2>/dev/null 1>&2 sign-efi-sig-list -t "$(date --date='1 second' +'%Y-%m-%d %H:%M:%S')" -k ${key_dir}/PK.key -c ${key_dir}/PK.crt KEK ${key_dir}/KEK.esl ${key_dir}/KEK.auth
  2>/dev/null 1>&2 sign-efi-sig-list -t "$(date --date='1 second' +'%Y-%m-%d %H:%M:%S')" -k ${key_dir}/KEK.key -c ${key_dir}/KEK.crt db ${key_dir}/DB.esl ${key_dir}/DB.auth

  chmod 0600 ${key_dir}/*.key
}

function sign_efis() {
  echo "Signing efi executables inside ${esp_dir}"

  for executable in $(find ${esp_dir} -type f -iname "*.efi"); do
    2>/dev/null 1>&2 sbsign --key ${key_dir}/DB.key --cert ${key_dir}/DB.crt --output $executable $executable
    echo "  Signed ${executable}"
  done
}

function verf_efis() {
  echo "Verifying signatures"

  for executable in $(find ${esp_dir} -type f -iname "*.efi"); do
    2>/dev/null 1>&2 sbverify $executable --cert ${key_dir}/DB.crt && echo "  Verified signature for ${executable}" || ret_error "  Cannot verify signature for ${executable}"
  done
}

case $1 in
  "help")
    echo "Available options are:"
    print_usage
    ;;

  "generate")
    echo "Generating unified kernel images"

    for kernel in ${boot_dir}/vmlinuz*; do
      kernel_name=$(basename ${kernel} | sed 's/vmlinuz-//')
      echo "  Generating ${kernel_name}"

      initrds="${boot_dir}/initramfs-${kernel_name}.img"
      initrds_fallback="${boot_dir}/initramfs-${kernel_name}-fallback.img"

      if [[ -f $initrds ]]; then
        echo "    Found ${initrds}"
      else
        echo "    Warning, cannot find ${boot_dir}/initramfs-${kernel_name}.img, trying to generate it using mkinitcpio"
        mkinitcpio -p ${kernel_name}

          if [[ -f $initrds ]]; then
            echo "    Found ${initrds}"
          else
            error "    Error, mkinitcpio didn't produce an initramfs image, aborting..."
          fi
      fi

      if [[ -f $initrds_fallback ]]; then
        echo "    Found ${initrds_fallback}"
        initrds_fallback_use="true"
      fi

      if [[ -f "/boot/intel-ucode.img" ]]; then
        initrds="${initrds} /boot/intel-ucode.img"
        initrds_fallback="${initrds_fallback} /boot/intel-ucode.img"
        echo "    Found /boot/intel-ucode.img"
      fi

      if [[ -f "/boot/amd-ucode.img" ]]; then
        initrds="${initrds} /boot/amd-ucode.img"
        initrds_fallback="${initrds_fallback} /boot/amd-ucode.img"
        echo "    Found /boot/amd-ucode.img"
      fi

      if [[ -f "${boot_dir}/cmdline-${kernel_name}" ]]; then
        cmdline="${boot_dir}/cmdline-${kernel_name}"
        echo "    Found ${cmdline}"
      elif [[ -f "/etc/kernel/cmdline" ]]; then
        cmdline=/etc/kernel/cmdline
        echo "    Found ${cmdline}"
      else
        error "    Error, cannot find cmdline for ${kernel_name}"
      fi

      echo "    Writting ${esp_dir}/EFI/${esp_name}/${kernel_name}.efi"

      objcopy \
        --add-section .osrel="/usr/lib/os-release" --change-section-vma .osrel=0x20000 \
        --add-section .cmdline="${cmdline}" --change-section-vma .cmdline=0x30000 \
        --add-section .linux="${kernel}" --change-section-vma .linux=0x40000 \
        --add-section .initrd=<(cat ${initrds}) --change-section-vma .initrd=0x3000000 \
        "${efi_stub}" "${esp_dir}/EFI/${esp_name}/${kernel_name}.efi"

      if [[ $initrds_fallback_use == "true" ]]; then
        echo "    Writting ${esp_dir}/EFI/${esp_name}/${kernel_name}-fallback.efi"

        objcopy \
          --add-section .osrel="/usr/lib/os-release" --change-section-vma .osrel=0x20000 \
          --add-section .cmdline="${cmdline}" --change-section-vma .cmdline=0x30000 \
          --add-section .linux="${kernel}" --change-section-vma .linux=0x40000 \
          --add-section .initrd=<(cat ${initrds_fallback}) --change-section-vma .initrd=0x3000000 \
          "${efi_stub}" "${esp_dir}/EFI/${esp_name}/${kernel_name}-fallback.efi"
      fi
    done
    ;;

  "remove")
    case $2 in
      "orphaned")
        echo "Removing orphaned unified kernel images"

        for unified_image in ${esp_dir}/EFI/${esp_name}/linux-*.efi; do
          kernel_name=$(basename $unified_image | sed 's/\.efi//')

          if [[ $kernel_name =~ "-fallback" ]]; then
            kernel_name=$(echo ${kernel_name} | sed 's/-fallback//')

            if [[ ! -f "${boot_dir}/initramfs-${kernel_name}-fallback.img" ]] || [[ ! -f "${boot_dir}/vmlinuz-${kernel_name}" ]]; then
              echo "  Removing orphaned unified image for kernel ${kernel_name}-fallback"
              rm ${unified_image}
            else
              echo "  Found kernel image and initramfs for ${kernel_name}-fallback"
            fi
          else
            if [[ ! -f "${boot_dir}/initramfs-${kernel_name}.img" ]] || [[ ! -f "${boot_dir}/vmlinuz-${kernel_name}" ]]; then
              echo "  Removing orphaned unified image for kernel ${kernel_name}"
              rm ${unified_image}
            else
              echo "  Found kernel image and initramfs for ${kernel_name}"
            fi
          fi
        done
        ;;

      "all")
        echo "Removing all unified kernel images"

        for unified_image in ${esp_dir}/EFI/${esp_name}/linux-*.efi; do
          kernel_name=$(basename $unified_image | sed 's/\.efi//')
          echo "  Removing unified kernel image for kernel ${kernel_name}"
          rm $unified_image
        done
        ;;

      *)
        if [[ -f "${esp_dir}/EFI/${esp_name}/$2.efi" ]]; then
          echo "Removing unified kernel image for kernel $2"
          rm ${esp_dir}/EFI/${esp_name}/$2.efi
        else
          echo "Kernel image for kernel $2 not found"
        fi

        ;;
    esac
    ;;

  "generate-keys")
    check_keys && generate_keys || echo "Keys already generated"
    ;;

  "sign")
    check_keys && echo "No secure boot keys found" && generate_keys || true

    sign_efis && verf_efis || error "Error signing executables"
    ;;

  *)
    echo "Invalid usage, please do:"
    print_usage
    exit 1
    ;;
esac

# vim: set filetype=sh
